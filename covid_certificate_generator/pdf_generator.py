# AUTOGENERATED! DO NOT EDIT! File to edit: pdf_generator.ipynb (unless otherwise specified).

__all__ = ['PDFGenerator']

# Cell
import datetime
import pandas as pd
#from fpdf import FPDF
from covid_certificate_generator import pdf_helper
import io, sys, os
import tempfile
import pathlib

# Cell
class PDFGenerator:
    config = None # Dict configuration
    school = None
    school_sign = None
    pdf_w=210
    pdf_h=297

    def __init__(self, config_file=None):
        """
        Constructor
        :param config_file: str, Path to config file
        :return:
        """
    def generate_one_attestation(self, prenom_parent, nom_parent, prenom_enfant, nom_enfant, date_naissance, moyen):
        self.pdf.add_page()
        #pdf.lines()
        self.pdf.titles()
        self.pdf.texte_parent(prenom_parent, nom_parent)
        self.pdf.texte_enfant(prenom_enfant, nom_enfant,date_naissance, moyen)
        self.pdf.texte_etablissement(
            self.school['school_name'], self.school['school_adress'], self.school_sign, self.school['city'])

    def generate(self, row):
        self.generate_one_attestation(row.PrenomParent, row.NomParent, row.PrenomEnfant, row.NomEnfant, row.DateNaissance, row.Moyen)


    def get_pdf(self, students_filename, students_data, school_sign, school):
#         students_file = io.BytesIO(students_file)
        self.school_sign = school_sign
        self.school = school
        try:
            if '.csv' in students_filename:
                # Assume that the user uploaded a CSV file
                df = pd.read_csv(students_data)
                if len(df.columns) == 1: # Is separator , ?
                    df = pd.read_csv(io.BytesIO(students_data.getbuffer()), sep=';')
                    if len(df.columns) == 1: # Is separator , ?
                        df = pd.read_csv(io.BytesIO(students_data.getbuffer()), sep='\t')
            else:
                # Assume that the user uploaded an excel file
                df = pd.read_excel(students_data) #io.BytesIO(decoded)
        except:
            error = f'ERREUR Ã  la lecture du fichier {students_filename}: {sys.exc_info()[0]}'
            print(error)
            raise

        if len(df.columns) < 6:
            raise ValueError("Format de fichier invalide : pas assez de colonnes !")
        self.pdf = pdf_helper.PDF(orientation='P', unit='mm', format='A4')
        self.pdf.set_author('Data For Good France')
        _ = df.apply(self.generate, axis=1)

    def get_pdf_from_file(self, students_filename, school_sign, school, output_name):
        # Read file
        with open(students_filename, 'rb') as fh:
            students_data = io.BytesIO(fh.read())
        self.get_pdf(students_filename, students_data, school_sign, school)
        _ = self.pdf.output(output_name,'F')

    def get_temp_file(self, ext=None):
        tmp_dir = tempfile._get_default_tempdir()
        tmp_name = next(tempfile._get_candidate_names())
        if ext:
            return os.path.join(tmp_dir, tmp_name + ext)
        else:
            return os.path.join(tmp_dir, tmp_name)
    def get_pdf_from_BytesIO(self, students_filename, students_data, school_sign_filename, school_sign_data, school):
        school_sign_filename = self.get_temp_file(school_sign_filename)
        with open(school_sign_filename, "wb") as f:
            f.write(school_sign_data.getbuffer())
        self.get_pdf(students_filename, students_data, school_sign_filename, school)
        output_name = self.get_temp_file('.pdf')
        _ = self.pdf.output(output_name,'F')
        # Clean temp file for school image
        path = pathlib.Path(school_sign_filename)
        path.unlink()
        return output_name
        #return self.pdf.output(dest='I')
