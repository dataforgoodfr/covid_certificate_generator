# AUTOGENERATED! DO NOT EDIT! File to edit: pdf_generator.ipynb (unless otherwise specified).

__all__ = ['PDFGenerator']

# Cell
import datetime
import pandas as pd
from covid_certificate_generator import pdf_helper
import io, sys, os
import tempfile
import pathlib
import logging
import time
import base64

# Cell
class PDFGenerator:
    config = None # Dict configuration
    school = None
    school_sign = None
    logger = None
    num_pages = 0
    pdf_w=210
    pdf_h=297

    def __init__(self):
        """
        Constructor
        :param: None
        :return:
        """
        logger = logging.getLogger("download")
        formatter = logging.Formatter("%(asctime)s -  %(name)-12s %(levelname)-8s %(message)s")
        logger.setLevel(logging.DEBUG)
        # If the log directory exist we write to it
        # We do not create it if not exist as in AWS Lambda we don't whant to do it
        if os.path.exists("./logs/"):
            log_file = f"./logs/pdf_generator-{datetime.datetime.today().strftime('%Y-%m-%d')}.log"
            fh = logging.FileHandler(log_file)
            fh.setLevel(logging.DEBUG)
            fh.setFormatter(formatter)
            logger.addHandler(fh) # Output to file
        logger.addHandler(logging.StreamHandler()) # And to console
        self.logger = logger
        #logger.info(f'Starting...')

    def get_temp_file(self, ext=None):
        tmp_dir = tempfile._get_default_tempdir()
        tmp_name = next(tempfile._get_candidate_names())
        if ext:
            return os.path.join(tmp_dir, tmp_name + ext)
        else:
            return os.path.join(tmp_dir, tmp_name)

    def generate_one_attestation(self, prenom_parent, nom_parent, prenom_enfant, nom_enfant, date_naissance, moyen):
        self.pdf.add_page()
        self.pdf.titles()
        self.pdf.texte_parent(prenom_parent, nom_parent)
        self.pdf.texte_enfant(prenom_enfant, nom_enfant,date_naissance, moyen)
        self.pdf.texte_etablissement(
            self.school['school_name'], self.school['school_adress'], self.school_sign, self.school['city'])

    def generate(self, row):
        self.generate_one_attestation(row.PrenomParent, row.NomParent, row.PrenomEnfant, row.NomEnfant, row.DateNaissance, row.Moyen)

    def get_pdf(self, students_data, school_sign, school):

        self.school_sign = school_sign
        self.school = school
        try:
            if isinstance(students_data, str) and len(students_data)<256:
                with open(students_data, 'rb') as fh:
                    students_data = io.BytesIO(fh.read())
            header = students_data.read(3)
            students_data.seek(0,0)
            XLS = b'\xd0\xcf\x11'
            XLSX = b'PK\x03'
            CSV = b'\xef\xbb\xbf' # UTF-8 Unicode (with BOM) text
            ascii_text = all(c > 60 and c < 128 for c in header)
            if header == CSV or ascii_text:
                #if '.csv' in students_filename:
                # The user uploaded a CSV file
                df = pd.read_csv(students_data)
                if len(df.columns) == 1: # Is separator , ?
                    students_data.seek(0,0)
                    df = pd.read_csv(students_data, sep=';')
                    if len(df.columns) == 1: # Is separator \t ?
                        students_data.seek(0,0)
                        df = pd.read_csv(students_data, sep='\t')
            elif header in (XLS, XLSX):
                df = pd.read_excel(students_data)
            else:
                # Assume that the user uploaded an excel file
                df = pd.read_excel(students_data)
        except:
            error = f'ERREUR Ã  la lecture du fichier : {sys.exc_info()[0]}'
            self.logger.error(error)
            raise

        if len(df.columns) < 6:
            raise ValueError("Format de fichier invalide : pas assez de colonnes !")
        self.pdf = pdf_helper.PDF(orientation='P', unit='mm', format='A4')
        self.pdf.set_author('Data For Good France')
        _ = df.apply(self.generate, axis=1)
        self.num_pages = len(df)


    def get_pdf_from_file(self, students_file, school_sign, school, output_name, return_object = False):
        start_time = time.time()
        self.logger.debug(f"Starting get_pdf_from_file for {school['school_name']}")
        # Read file
#         with open(students_file, 'rb') as fh:
#             students_data = io.BytesIO(fh.read())
        self.get_pdf(students_file, school_sign, school)

        if return_object:
            result = self.pdf.output(output_name,"S")
        else:
            _ = self.pdf.output(output_name,'F')
            result = None
        exec_time = f'Execution time for {self.num_pages} pages: {round(time.time() - start_time, 3)} second(s).'
        self.logger.info(exec_time)
        return result

    def encode_to_text(self, byte_content):
        # Thanks to https://stackoverflow.com/questions/37225035/serialize-in-json-a-base64-encoded-data
        ENCODING = 'utf-8'
        # base64 encode read data
        # result: bytes (again)
        base64_bytes = base64.b64encode(byte_content)
        # tdecode these bytes to text
        # result: string (in utf-8)
        base64_string = base64_bytes.decode(ENCODING)
        return base64_string

    def decode_to_byte(self, text_content):
        ENCODING = 'utf-8'
        decoded = base64.b64decode(text_content)
        return io.BytesIO(decoded)
        #return io.BytesIO(base64.b64decode(text_content).decode(ENCODING))

    def get_pdf_from_json_payload(self, json_payload):
        start_time = time.time()
        self.logger.debug(f'Starting get_pdf_from_BytesIO...')
        students_data = json_payload['students_file']
        students_data = self.decode_to_byte(students_data)
        school_sign_data = json_payload['school_sign']
        school_sign_data = self.decode_to_byte(school_sign_data)
        school = json_payload['school']
#         if len(school_sign_filename) < 2:
#             school_sign_filename = ''
#         school_sign_filename = self.get_temp_file(school_sign_filename)
#         with open(school_sign_filename, "wb") as f:
#             f.write(school_sign_data.getbuffer())
#         self.get_pdf(students_data, school_sign_filename, school)
        self.get_pdf(students_data, school_sign_data, school)
#         output_name = self.get_temp_file('.pdf')
#         _ = self.pdf.output(output_name,'F')
#         # Clean temp file for school image
#         path = pathlib.Path(school_sign_filename)
#         path.unlink()
        exec_time = f'Execution time for {self.num_pages} pages: {round(time.time() - start_time, 3)} second(s).'
        self.logger.info(exec_time)
        return self.pdf.output(None,"S")
        #return self.pdf.output(dest='I')
