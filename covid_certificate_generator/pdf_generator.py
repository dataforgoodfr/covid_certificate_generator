# AUTOGENERATED! DO NOT EDIT! File to edit: pdf_generator.ipynb (unless otherwise specified).

__all__ = ['PDFGenerator']

# Cell
import datetime
import pandas as pd
#from fpdf import FPDF
from covid_certificate_generator import pdf_helper
import io, sys, os
import tempfile
import pathlib
import logging
import time

# Cell
class PDFGenerator:
    config = None # Dict configuration
    school = None
    school_sign = None
    logger = None
    num_pages = 0
    pdf_w=210
    pdf_h=297

    def __init__(self, config_file=None):
        """
        Constructor
        :param config_file: str, Path to config file
        :return:
        """
        logger = logging.getLogger("download")
        formatter = logging.Formatter("%(asctime)s -  %(name)-12s %(levelname)-8s %(message)s")
        logger.setLevel(logging.DEBUG)
        log_file = f"./logs/pdf_generator-{datetime.datetime.today().strftime('%Y-%m-%d')}.log"
        fh = logging.FileHandler(log_file)
        fh.setLevel(logging.DEBUG)
        fh.setFormatter(formatter)
        logger.addHandler(fh) # Output to file
        logger.addHandler(logging.StreamHandler()) # And to console
        self.logger = logger
        #logger.info(f'Starting...')

    def get_temp_file(self, ext=None):
        tmp_dir = tempfile._get_default_tempdir()
        tmp_name = next(tempfile._get_candidate_names())
        if ext:
            return os.path.join(tmp_dir, tmp_name + ext)
        else:
            return os.path.join(tmp_dir, tmp_name)

    def generate_one_attestation(self, prenom_parent, nom_parent, prenom_enfant, nom_enfant, date_naissance, moyen):
        self.pdf.add_page()
        self.pdf.titles()
        self.pdf.texte_parent(prenom_parent, nom_parent)
        self.pdf.texte_enfant(prenom_enfant, nom_enfant,date_naissance, moyen)
        self.pdf.texte_etablissement(
            self.school['school_name'], self.school['school_adress'], self.school_sign, self.school['city'])

    def generate(self, row):
        self.generate_one_attestation(row.PrenomParent, row.NomParent, row.PrenomEnfant, row.NomEnfant, row.DateNaissance, row.Moyen)

    def get_pdf(self, students_data, school_sign, school):

        self.school_sign = school_sign
        self.school = school
        try:
            if isinstance(students_data, str) and len(students_data)<256:
                with open(students_data, 'rb') as fh:
                    students_data = io.BytesIO(fh.read())
            header = students_data.read(3)
            students_data.seek(0,0)
            XLS = b'\xd0\xcf\x11'
            XLSX = b'PK\x03'
            CSV = b'\xef\xbb\xbf' # UTF-8 Unicode (with BOM) text
            ascii_text = all(c > 60 and c < 128 for c in header)
            if header == CSV or ascii_text:
                #if '.csv' in students_filename:
                # The user uploaded a CSV file
                df = pd.read_csv(students_data)
                if len(df.columns) == 1: # Is separator , ?
                    students_data.seek(0,0)
                    df = pd.read_csv(students_data, sep=';')
                    if len(df.columns) == 1: # Is separator \t ?
                        students_data.seek(0,0)
                        df = pd.read_csv(students_data, sep='\t')
            elif header in (XLS, XLSX):
                df = pd.read_excel(students_data)
            else:
                # Assume that the user uploaded an excel file
                df = pd.read_excel(students_data)
        except:
            error = f'ERREUR Ã  la lecture du fichier : {sys.exc_info()[0]}'
            self.logger.error(error)
            raise

        if len(df.columns) < 6:
            raise ValueError("Format de fichier invalide : pas assez de colonnes !")
        self.pdf = pdf_helper.PDF(orientation='P', unit='mm', format='A4')
        self.pdf.set_author('Data For Good France')
        _ = df.apply(self.generate, axis=1)
        self.num_pages = len(df)


    def get_pdf_from_file(self, students_file, school_sign, school, output_name, return_object = False):
        start_time = time.time()
        self.logger.debug(f"Starting get_pdf_from_file for {school['school_name']}")
        # Read file
#         with open(students_file, 'rb') as fh:
#             students_data = io.BytesIO(fh.read())
        self.get_pdf(students_file, school_sign, school)

        if return_object:
            result = self.pdf.output(output_name,"S")
        else:
            _ = self.pdf.output(output_name,'F')
            result = None
        exec_time = f'Execution time for {self.num_pages} pages: {round(time.time() - start_time, 3)} second(s).'
        self.logger.info(exec_time)
        return result

    def get_pdf_from_BytesIO(self, students_filename, students_data, school_sign_filename, school_sign_data, school):
        start_time = time.time()
        self.logger.debug(f'Starting get_pdf_from_BytesIO...')
        if len(school_sign_filename) < 2:
            school_sign_filename = ''
        school_sign_filename = self.get_temp_file(school_sign_filename)
        with open(school_sign_filename, "wb") as f:
            f.write(school_sign_data.getbuffer())
        self.get_pdf(students_data, school_sign_filename, school)
        output_name = self.get_temp_file('.pdf')
        _ = self.pdf.output(output_name,'F')
        # Clean temp file for school image
        path = pathlib.Path(school_sign_filename)
        path.unlink()
        exec_time = f'Execution time for {self.num_pages} pages: {round(time.time() - start_time, 3)} second(s).'
        self.logger.info(exec_time)
        return output_name
        #return self.pdf.output(dest='I')
